---
title: "Sample size"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = here::here())
library(tidyverse)
theme_set(theme_light(base_family = "Lato"))
library(brms)
library(extraDistr)
library(HDInterval)
library(tidybayes)
library(logger)
my_seed <- 99
set.seed(my_seed)
```

# Set up

We first create the necessary directories, if they don't exist already.

```{r dirs}
# Save simulation output here
dir.create("./models/sims", FALSE, TRUE)
# Save figure output here
dir.create("./figs/sample-size", FALSE)
```

# Estimate teams' standard deviation

We obtain an estimate of the teams' standard deviation based on data from Silberzahn et al.

```{r Silberzahn}
# Load in Silberzahn et al. data: https://osf.io/fa743/
silber <- read_csv("https://osf.io/fa743/download") %>%
  mutate(
    z_score = log(OR) / ((log(OR) - log(OR_lo)) / 1.96)
  ) %>%
  # Filter out extremely high z_scores
  filter(z_score < 6)

# Mean z-score
round(mean(silber$z_score), 2)

# Set weakly informative priors for intercept and scale parameters.
priors <- c(
  prior(normal(0, 3), class = Intercept),
  prior(cauchy(0, 1), class = sd)
)

# Run brm to estimate teams' SD (= `(1 | Team)` in the model)
silber_sd <- brm(
  z_score ~ (1 | Team),
  data = silber,
  prior = priors,
  chain = 4,
  iter = 4000,
  cores = 4,
  seed = my_seed,
  # Use cmdstanr to enable multi-core multi-threading processing
  backend = "cmdstanr", threads = threading(4),
  control = list(adapt_delta = 0.9999, max_treedepth = 15),
  file = "./models/sims/silber_sd"
)

# Extract SD estimate and 95 CrI
SD <- summary(silber_sd)$random$Team[1]
lower <- summary(silber_sd)$random$Team[3]
upper <- summary(silber_sd)$random$Team[4]

# Create a vector of quantiles of the estimated teams' SD
# min, 1st quartile, mean, 3rd quartile, max = 0.00 0.25 0.50 0.75 1.00
quantiles <- quantile(seq(lower, upper, by = 0.1), probs = seq(0, 1, 0.25),  na.rm = FALSE)
quantiles <- c(quantiles[[1]], quantiles[[2]], quantiles[[3]], quantiles[[4]], quantiles[[5]])
n_teams <- seq(5, 40, by = 5)

# Get all unique combos of number of teams and quantiles of SD.
n_ts_qs <- expand_grid(n_teams, quantiles)
```

# Prepare functions for simulation

The following functions define routines to simulate data, fir the models to the data, and set up the simulation loop.

```{r functions}
# Simulate data ####
# For each iteration in the simulation loop, simulate data table of z-scores
# n = number of teams
# sd = teams' SD used to simulate z-scores
simulate_data <- function(n, sd) {
  tibble::tibble(
    z_score = rnorm(n, 0, sd),
    team = letters[1:n]
  )
}

# Fit brm to simulated data ####
run_brm <- function(data) {
  # weakly informative priors
  priors <- c(
    brms::prior(normal(0, 3), class = Intercept),
    brms::prior(cauchy(0, 1), class = sd)
  )
  
  # fit brm
  meta_bm <- brms::brm(
    z_score ~
      (1 | team),
    data = data,
    prior = priors,
    chain = 4,
    iter = 6000,
    cores = 4,
    backend = "cmdstanr", threads = brms::threading(4),
    control = list(adapt_delta = 0.9999, max_treedepth = 15),
  )
  
  return(meta_bm)
}

# Simulation iteration loop ####
# This function defines the simulation loop.
# The mean and SD of the simulated teams' SD across 10 iterations (per
# n-teams/sd combos) are returned.
run_simulations <- function(n, sd) {
  data <- simulate_data(n, sd)

  sd_team_i <- numeric()
  
  log_info("Model: {n}, {sd}")

  for (iter in 1:10) {
    log_info("--- Iteration {iter}")
    brm_model <- run_brm(data)
    brm_summ <- summary(brm_model)
    sd_team_i <- c(sd_team_i, brm_summ$random$team[4] - brm_summ$random$team[3]) 
  }

  sd_team_mean <- mean(sd_team_i, na.rm = TRUE)
  sd_team_sd <- sd(sd_team_i, na.rm = TRUE)
  
  return(list(sd_team_mean, sd_team_sd))
}
```

# Run the simulations

```{r run-sims}
sample_file <- "./models/sims/sample_sims.rds"

# If results file already exists, read it. Otherwise run the simulations.
if (file.exists(sample_file)) {
  # read results file
  log_info("Reading file...\n")
  sample_sims <- readRDS(sample_file)
  log_info("Done!")
} else {
  # run simulations
  sample_sims <- tibble(
    n_teams = n_ts_qs$n_teams,
    quants = n_ts_qs$quantiles,
    sd_team = map2(
      n_teams, quants,
      ~run_simulations(.x, .y)
    )
  )

  # save results to file
  saveRDS(sample_sims, sample_file)
}
```

# Plot results

```{r plot}
sample_cri <- sample_sims %>%
  unnest(sd_team) %>%
  mutate(sd_team = unlist(sd_team)) %>% 
  filter(sd_team > 0) %>%
  rename(cri = sd_team)

labels <- tibble(
  x = c(0.5, 0.25, 0.9, 0.3, 1.3),
  y = c(1.25, 0.7, 1.5, 0.1, 1.15),
  labs = c("Mean", "1st quart.", "3rd quart.", "Min", "Max")
)

arrows <- tibble(
    x1 = c(0.5, 0.25, 0.9, 0.25, 1.3),
    y1 = c(1.15, 0.6, 1.4, 0.1, 1.2),
    x2 = c(0.63, 0.33, 0.97, 0.05, 1.33),
    y2 = c(0.8, 0.45, 1.2, 0.1, 1.39)
  )

sample_cri %>%
  ggplot(aes(quants, cri)) +
  geom_line(aes(colour = as.factor(n_teams))) +
  geom_point(aes(colour = as.factor(n_teams)), size = 4) +
  geom_hline(yintercept = 1) +
  geom_hline(yintercept = 2, linetype = "dashed") +
  geom_text(
    data = labels, aes(x, y, label = labs),
    family = "Lato"
  ) +
  geom_curve(
    data = arrows, aes(x = x1, y = y1, xend = x2, yend = y2),
    arrow = arrow(length = unit(0.07, "inch")), size = 0.4,
    color = "gray20", curvature = 0.3
  ) +
  scale_x_continuous(breaks = round(quantiles, 2)) +
  scale_color_manual(values = c("#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b")) +
  labs(
    title = "95% CrI width depending on teams' true SD and number of teams",
    x = "Teams' true standard deviation",
    y = "95% CrI width",
    colour = "N of teams",
    caption = "The values on the x-axis are the quartiles (0, 0.25, 0.5, 0.75, 1)\nof the estimated teams' SD from Silberzahn et al."
  )

ggsave("./figs/sample-size/cri-width-nteams-true-sd.pdf", width = 7, height = 5, device = cairo_pdf)
```

